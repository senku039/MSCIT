<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reading Speed Test</title>
  <link rel="stylesheet" href="/theme.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: url('/IMAGES/kids.jpg') no-repeat center center/cover; font-family: Arial, sans-serif; padding: 20px; }
    .container { max-width: 920px; margin-top: 50px; background: rgba(255,255,255,.95); padding: 30px; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.18); }
    #textToRead { height: 220px; overflow-y: auto; border: 1px solid #ccd6f3; border-radius: 10px; padding: 14px; margin-bottom: 18px; background: #f8fbff; }
    .camera-block { border: 1px solid #ccd6f3; border-radius: 12px; background: #f8fbff; padding: 12px; margin-bottom: 10px; }
    video { width: 100%; max-height: 340px; min-height: 260px; object-fit: cover; display: none; border-radius: 10px; }
    #trackingHint { font-size: .88rem; color: #5f6b86; margin-top: 6px; display: none; }
  </style>
</head>
<body>
  <button class="global-back-btn" type="button" onclick="window.location.href='index.html'">‚Üê Back</button>
  <div class="container">
    <h1 class="text-center mb-3">Reading Speed Test</h1>
    <p class="text-muted">To prevent false high scores, the test validates minimum reading time and a quick comprehension check.</p>
    <div class="camera-block">
      <video id="webcam" autoplay playsinline muted></video>
      <div id="trackingHint">Tip: keep your full face centered, with both eyes visible, for better scoring quality.</div>
      <div id="cameraStatus" class="alert alert-warning py-2 mt-2" style="display:none;"></div>
      <div id="trackingPanel" class="alert alert-info py-2" style="display:none;"></div>
    </div>
    <small class="text-muted d-block mb-2">Privacy note: this test uses <strong>video only</strong> for focus/face estimation. It does <strong>not</strong> capture audio.</small>
    <div class="mb-3">
      <p>Read the following text naturally:</p>
      <div id="textToRead"></div>
    </div>

    <div id="questionBlock" class="alert alert-light border" style="display:none;">
      <div id="questionText" class="fw-semibold mb-2"></div>
      <div id="questionOptions"></div>
      <button id="submitAnswerBtn" class="btn btn-outline-primary btn-sm mt-2" style="display:none;">Submit Answer</button>
    </div>

    <button id="startBtn" class="btn btn-primary w-100">Start Reading</button>
    <button id="stopBtn" class="btn btn-danger w-100 mt-3" style="display: none;">Stop Reading</button>
    <div id="result" class="mt-4 text-center" style="font-size: 1.08em;"></div>
    <button id="finishTestBtn" class="btn btn-info w-100 mt-3" style="display: none;">Finish Test</button>
  </div>

  <script>
    const passages = [
      {
        text: "Maya loves visiting the library after school. She picks a new book every week and reads with her grandmother in the evening. Reading together helps her learn new words and understand stories better.",
        question: "Who reads with Maya in the evening?",
        options: ["Her teacher", "Her grandmother", "Her brother"],
        answer: "Her grandmother"
      },
      {
        text: "Arjun planted tomato seeds in a small garden behind his house. Every morning he watered the plants and checked for new leaves. After a few weeks, tiny green tomatoes appeared.",
        question: "What did Arjun plant?",
        options: ["Tomato seeds", "Rice seeds", "Rose flowers"],
        answer: "Tomato seeds"
      },
      {
        text: "The school science club built a small weather station. Students measured temperature, wind, and rainfall each day. They compared the data and learned how weather changes over time.",
        question: "What did students measure daily?",
        options: ["Only temperature", "Temperature, wind and rainfall", "Only rainfall"],
        answer: "Temperature, wind and rainfall"
      },
      {
        text: "On Sunday, Aisha and her brother cleaned their room. They sorted books, folded clothes, and arranged toys on shelves. Their room looked bright, neat, and easy to study in.",
        question: "What did they arrange on shelves?",
        options: ["Shoes", "Toys", "Food"],
        answer: "Toys"
      }
    ];

    const MAX_VALID_WPM = 420;
    const MIN_VALID_FOCUS_SECONDS = 5;

    let selectedPassage;
    let startTime, endTime, focusTime = 0, tracking = false, videoStream, stopPressed = false;
    let pendingMetrics = null;
    let faceDetector = null;
    let faceTrackTimer = null;
    let faceVisibleSeconds = 0;
    let eyeMovementScore = 0;
    let detectionSamples = 0;
    let stableFaceSamples = 0;
    let dynamicSampleRateMs = 700;
    let trackingHealthScore = 0;
    let lastFaceCenter = null;
    let lastFaceBox = null;
    let faceHistory = [];
    let focusTimer = null;
    let lookAwaySeconds = 0;
    let lookAwayAlerts = 0;
    let faceMissingStreak = 0;

    function randomPick(items){return items[Math.floor(Math.random()*items.length)];}

    function loadPassage() {
      selectedPassage = randomPick(passages);
      document.getElementById('textToRead').innerText = selectedPassage.text;
    }

    function renderQuestion() {
      const block = document.getElementById('questionBlock');
      block.style.display = 'block';
      document.getElementById('questionText').textContent = selectedPassage.question;
      const optionsHost = document.getElementById('questionOptions');
      optionsHost.innerHTML = '';
      selectedPassage.options.forEach((opt, i) => {
        const id = `opt_${i}`;
        optionsHost.innerHTML += `<div class="form-check"><input class="form-check-input" type="radio" name="answer" id="${id}" value="${opt}"><label class="form-check-label" for="${id}">${opt}</label></div>`;
      });
      document.getElementById("submitAnswerBtn").style.display = "inline-block";
    }


    function stopFaceTracking() {
      if (faceTrackTimer) {
        clearInterval(faceTrackTimer);
        faceTrackTimer = null;
      }
      lastFaceCenter = null;
    }

    function updateTrackingPanel() {
      const panel = document.getElementById('trackingPanel');
      panel.style.display = 'block';
      const qualityPct = detectionSamples ? ((stableFaceSamples / detectionSamples) * 100).toFixed(0) : '0';
      panel.innerHTML = `Face presence: <strong>${faceVisibleSeconds}s</strong> | Looking away: <strong>${lookAwaySeconds}s</strong> | Eye movement: <strong>${eyeMovementScore.toFixed(1)}</strong> | Tracking quality: <strong>${qualityPct}%</strong>`;
    }

    function calcMotion(points) {
      if (points.length < 2) return 0;
      let distance = 0;
      for (let i = 1; i < points.length; i += 1) {
        const dx = points[i].x - points[i - 1].x;
        const dy = points[i].y - points[i - 1].y;
        distance += Math.sqrt((dx * dx) + (dy * dy));
      }
      return distance / (points.length - 1);
    }

    function getEyeProxyFromLandmarks(face, centerY) {
      if (!face.landmarks || !face.landmarks.length) return centerY;
      const eyeHints = ['eye', 'pupil'];
      const eyeLandmarks = face.landmarks.filter((l) => eyeHints.some((hint) => (l.type || '').toLowerCase().includes(hint)));
      if (!eyeLandmarks.length) return centerY;
      const avgY = eyeLandmarks.reduce((sum, lm) => sum + lm.location.y, 0) / eyeLandmarks.length;
      return avgY;
    }

    function deriveTrackingHealth(face, box) {
      const frameArea = Math.max((window.innerWidth || 1) * (window.innerHeight || 1), 1);
      const faceAreaRatio = (box.width * box.height) / frameArea;
      const hasUsefulBox = faceAreaRatio > 0.015;
      const landmarkBonus = face.landmarks && face.landmarks.length ? 8 : 0;
      return (hasUsefulBox ? 12 : 0) + landmarkBonus;
    }

    async function setupFaceTracking(video) {
      if (!('FaceDetector' in window)) return false;
      try {
        faceDetector = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
      } catch (_error) {
        return false;
      }

      stopFaceTracking();
      faceTrackTimer = setInterval(async () => {
        if (!tracking || !faceDetector || video.readyState < 2) return;
        try {
          const faces = await faceDetector.detect(video);
          detectionSamples += 1;
          if (!faces.length) {
            faceMissingStreak += 1;
            if (faceMissingStreak % 2 === 0) lookAwaySeconds += 1;
            if (faceMissingStreak === 2) {
              lookAwayAlerts += 1;
              const cameraStatus = document.getElementById('cameraStatus');
              cameraStatus.style.display = 'block';
              cameraStatus.className = 'alert alert-danger py-2 mt-2';
              cameraStatus.textContent = 'Looking away detected. Please keep your face toward the screen.';
            }
            updateTrackingPanel();
            return;
          }

          faceMissingStreak = 0;
          if (detectionSamples % 2 === 0) faceVisibleSeconds += 1;
          const box = faces[0].boundingBox;
          const cx = box.x + (box.width / 2);
          const cy = box.y + (box.height / 2);
          const eyeProxyY = getEyeProxyFromLandmarks(faces[0], cy);
          const frameScale = Math.max(box.width + box.height, 1);

          faceHistory.push({ x: cx, y: eyeProxyY });
          if (faceHistory.length > 10) faceHistory.shift();
          const smoothMotion = calcMotion(faceHistory);

          if (smoothMotion < 18) {
            stableFaceSamples += 1;
          }

          trackingHealthScore += deriveTrackingHealth(faces[0], box);

          if (lastFaceCenter) {
            const dx = Math.abs(cx - lastFaceCenter.x) / frameScale;
            const dy = Math.abs(eyeProxyY - lastFaceCenter.y) / frameScale;
            const boxDelta = lastFaceBox ? Math.abs((box.width * box.height) - lastFaceBox) / Math.max(lastFaceBox, 1) : 0;
            eyeMovementScore += Math.min(((dx + dy + boxDelta) * 100), 12);
          }
          lastFaceCenter = { x: cx, y: eyeProxyY };
          lastFaceBox = box.width * box.height;

          const cameraStatus = document.getElementById('cameraStatus');
          if (trackingHealthScore > 20 && faceMissingStreak === 0) {
            cameraStatus.className = 'alert alert-success py-2 mt-2';
            cameraStatus.textContent = 'Camera active. Face and eye movement tracking is stable.';
          }
          updateTrackingPanel();
        } catch (_error) {
          // ignore intermittent detection errors
        }
      }, dynamicSampleRateMs);
      return true;
    }

    async function startWebcam() {
      const video = document.getElementById('webcam');
      const cameraStatus = document.getElementById('cameraStatus');
      cameraStatus.style.display = 'none';
      cameraStatus.textContent = '';
      faceVisibleSeconds = 0;
      eyeMovementScore = 0;
      detectionSamples = 0;
      stableFaceSamples = 0;
      trackingHealthScore = 0;
      faceHistory = [];
      lookAwaySeconds = 0;
      lookAwayAlerts = 0;
      faceMissingStreak = 0;
      lastFaceBox = null;
      document.getElementById('trackingHint').style.display = 'block';
      document.getElementById('trackingPanel').style.display = 'none';
      stopFaceTracking();

      const mediaSupported = Boolean(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      if (!mediaSupported) {
        tracking = true;
        trackFocusTime();
        cameraStatus.style.display = 'block';
        cameraStatus.textContent = 'Camera API is unavailable in this browser. Continuing test without camera/face tracking.';
        updateTrackingPanel();
        return;
      }

      try {
        videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } } });
        video.srcObject = videoStream;
        video.style.display = 'block';
        await video.play();
        dynamicSampleRateMs = window.innerWidth < 768 ? 900 : 600;
        tracking = true;
        trackFocusTime();

        const faceTrackingEnabled = await setupFaceTracking(video);
        if (faceTrackingEnabled) {
          cameraStatus.style.display = 'block';
          cameraStatus.className = 'alert alert-success py-2 mt-2';
          cameraStatus.textContent = 'Camera active. Face/eye movement proxy tracking is enabled.';
          updateTrackingPanel();
        } else {
          cameraStatus.style.display = 'block';
          cameraStatus.className = 'alert alert-warning py-2 mt-2';
          cameraStatus.textContent = 'Camera active. Browser does not support built-in face detection; using focus-time fallback.';
          updateTrackingPanel();
        }
      } catch (_error) {
        tracking = true;
        trackFocusTime();
        cameraStatus.style.display = 'block';
        cameraStatus.className = 'alert alert-warning py-2 mt-2';
        cameraStatus.textContent = 'Camera access blocked/denied. Test will continue without camera tracking.';
        updateTrackingPanel();
      }
    }

    function stopWebcam() {
      if (videoStream) videoStream.getTracks().forEach(track => track.stop());
      document.getElementById('webcam').style.display = 'none';
      document.getElementById('trackingHint').style.display = 'none';
      tracking = false;
      stopFaceTracking();
      if (focusTimer) {
        clearTimeout(focusTimer);
        focusTimer = null;
      }
    }

    function trackFocusTime() {
      if (!tracking) return;
      focusTime++;
      focusTimer = setTimeout(trackFocusTime, 1000);
    }

    document.getElementById('startBtn').addEventListener('click', function() {
      focusTime = 0;
      startTime = Date.now();
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('stopBtn').style.display = 'block';
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('result').innerText = '';
      document.getElementById('cameraStatus').className = 'alert alert-warning py-2 mt-2';
      stopPressed = false;
      startWebcam();
    });

    document.getElementById('stopBtn').addEventListener('click', function() {
      if (stopPressed) return;
      stopPressed = true;
      document.getElementById('stopBtn').disabled = true;

      endTime = Date.now();
      const elapsedSeconds = Math.max((endTime - startTime) / 1000, 1);
      const wordCount = document.getElementById('textToRead').innerText.trim().split(/\s+/).filter(Boolean).length;
      const minExpectedSeconds = (wordCount / MAX_VALID_WPM) * 60;
      stopWebcam();
      pendingMetrics = { elapsedSeconds, wordCount, minExpectedSeconds, focusTime, faceVisibleSeconds, eyeMovementScore, lookAwaySeconds, lookAwayAlerts, detectionSamples, stableFaceSamples };
      renderQuestion();
      document.getElementById('result').innerText = 'Answer the quick comprehension question to validate the score.';
    });

    document.getElementById('submitAnswerBtn').addEventListener('click', function() {
      if (!pendingMetrics) return;
      const chosen = document.querySelector('input[name="answer"]:checked');
      if (!chosen) {
        document.getElementById('result').innerText = 'Please pick an answer to finish validation.';
        return;
      }
      const selected = chosen.value;
      const correct = selected === selectedPassage.answer;

      const rawWpm = (pendingMetrics.wordCount / pendingMetrics.elapsedSeconds) * 60;
      const suspiciousFast = pendingMetrics.elapsedSeconds < pendingMetrics.minExpectedSeconds;
      const reliableFocus = Math.max(pendingMetrics.focusTime, pendingMetrics.faceVisibleSeconds);
      const lowFocus = reliableFocus < MIN_VALID_FOCUS_SECONDS;
      const lookingAwayTooLong = pendingMetrics.lookAwaySeconds >= 4 || pendingMetrics.lookAwayAlerts >= 2;
      const weakTracking = pendingMetrics.detectionSamples > 6 && (pendingMetrics.stableFaceSamples / pendingMetrics.detectionSamples) < 0.35;

      if (!correct || suspiciousFast || lowFocus || lookingAwayTooLong || weakTracking) {
        const reasons = [];
        if (!correct) reasons.push('comprehension answer mismatch');
        if (suspiciousFast) reasons.push('unrealistically short reading time');
        if (lowFocus) reasons.push('insufficient focus/face-presence time');
        if (lookingAwayTooLong) reasons.push('frequent looking away from screen');
        if (weakTracking) reasons.push('camera tracking quality too low, keep face closer and centered');
        document.getElementById('result').innerText = `Result rejected for reliability (${reasons.join(', ')}). Please retake the test.`;
        sessionStorage.removeItem('reading_speed_score');
        sessionStorage.setItem('reading_speed_reliability', 'invalid');
      } else {
        const wordsPerMinute = Math.min(rawWpm, MAX_VALID_WPM);
        document.getElementById('result').innerText = `Validated reading speed: ${wordsPerMinute.toFixed(2)} WPM | Focus: ${pendingMetrics.focusTime}s | Face Presence: ${pendingMetrics.faceVisibleSeconds}s | Looking Away: ${pendingMetrics.lookAwaySeconds}s | Eye Movement Index: ${pendingMetrics.eyeMovementScore.toFixed(1)}`;
        sessionStorage.setItem('reading_speed_score', wordsPerMinute.toFixed(2));
        sessionStorage.setItem('reading_speed_reliability', 'valid');
      }

      sessionStorage.setItem('focus_time', pendingMetrics.focusTime);
      sessionStorage.setItem('face_presence_time', pendingMetrics.faceVisibleSeconds);
      sessionStorage.setItem('eye_movement_index', pendingMetrics.eyeMovementScore.toFixed(2));
      sessionStorage.setItem('looking_away_seconds', String(pendingMetrics.lookAwaySeconds));
      document.getElementById('finishTestBtn').style.display = 'block';
      document.getElementById('submitAnswerBtn').disabled = true;
    });

    document.getElementById('finishTestBtn').addEventListener('click', function() {
      window.location.href = "/dyslexia-prediction";
    });

    document.addEventListener('DOMContentLoaded', loadPassage);
  </script>
</body>
</html>
