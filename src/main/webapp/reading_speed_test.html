<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reading Speed Test</title>
  <link rel="stylesheet" href="/theme.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: url('/IMAGES/kids.jpg') no-repeat center center/cover; font-family: Arial, sans-serif; padding: 20px; }
    .container { max-width: min(1260px, 96vw); margin-top: clamp(16px, 3vh, 44px); background: rgba(255,255,255,.95); padding: clamp(18px, 2.4vw, 36px); border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.18); }
    #textToRead { height: clamp(240px, 38vh, 420px); overflow-y: auto; border: 1px solid #ccd6f3; border-radius: 10px; padding: 14px; margin-bottom: 18px; background: #f8fbff; }
    .camera-block { border: 1px solid #ccd6f3; border-radius: 12px; background: #f8fbff; padding: 12px; margin-bottom: 10px; }
    .video-shell { position: relative; width: 100%; max-height: 46vh; min-height: clamp(220px, 30vh, 360px); display: none; }
    video { width: 100%; height: 100%; object-fit: cover; border-radius: 10px; display: block; }
    #faceOverlay { position: absolute; inset: 0; width: 100%; height: 100%; border-radius: 10px; pointer-events: none; }
    #trackingHint { font-size: .88rem; color: #5f6b86; margin-top: 6px; display: none; }
  </style>
</head>
<body>
  <button class="global-back-btn" type="button" onclick="window.location.href='index.html'">‚Üê Back</button>
  <div class="container">
    <h1 class="text-center mb-3">Reading Speed Test</h1>
    <p class="text-muted">To prevent false high scores, the test validates minimum reading time and a quick comprehension check.</p>

    <video id="webcam" autoplay playsinline muted></video>
    <div id="cameraStatus" class="alert alert-warning py-2 mt-2" style="display:none;">State: idle</div>
    <div id="trackingPanel" class="alert alert-info py-2" style="display:none;"></div>
    <small class="text-muted d-block mb-2">Privacy note: this test uses <strong>video only</strong> for focus/face estimation. It does <strong>not</strong> capture audio.</small>

    <button id="startCameraBtn" class="btn btn-outline-primary btn-sm mb-3">Start Camera Tracking</button>

    <div class="mb-3">
      <p>Read the following text naturally:</p>
      <div id="textToRead"></div>
    </div>

    <div id="questionBlock" class="alert alert-light border" style="display:none;">
      <div id="questionText" class="fw-semibold mb-2"></div>
      <div id="questionOptions"></div>
      <button id="submitAnswerBtn" class="btn btn-outline-primary btn-sm mt-2" style="display:none;">Submit Answer</button>
    </div>

    <button id="startBtn" class="btn btn-primary w-100">Start Reading Test</button>
    <button id="stopBtn" class="btn btn-danger w-100 mt-3" style="display: none;">Stop Reading</button>
    <div id="result" class="mt-4 text-center" style="font-size: 1.08em;"></div>
    <button id="finishTestBtn" class="btn btn-info w-100 mt-3" style="display: none;">Finish Test</button>
  </div>

  <script>
    const passages = [
      { text: "Maya loves visiting the library after school. She picks a new book every week and reads with her grandmother in the evening. Reading together helps her learn new words and understand stories better.", question: "Who reads with Maya in the evening?", options: ["Her teacher", "Her grandmother", "Her brother"], answer: "Her grandmother" },
      { text: "Arjun planted tomato seeds in a small garden behind his house. Every morning he watered the plants and checked for new leaves. After a few weeks, tiny green tomatoes appeared.", question: "What did Arjun plant?", options: ["Tomato seeds", "Rice seeds", "Rose flowers"], answer: "Tomato seeds" },
      { text: "The school science club built a small weather station. Students measured temperature, wind, and rainfall each day. They compared the data and learned how weather changes over time.", question: "What did students measure daily?", options: ["Only temperature", "Temperature, wind and rainfall", "Only rainfall"], answer: "Temperature, wind and rainfall" }
    ];

    const MAX_VALID_WPM = 420;
    const MIN_VALID_FOCUS_SECONDS = 5;
    const DETECT_SAMPLE_MS = 140;
    const AWAY_TRIGGER_MS = 500;
    const AWAY_GRACE_MS = 300;
    const MIN_FACE_AREA_RATIO = 0.008;
    const MIN_CONFIDENCE = 0.2;

    // State machine required for stable integration with the wider project.
    const STATE = { IDLE: 'idle', RUNNING: 'running', SUBMITTED: 'submitted', FINISHED: 'finished' };
    let testState = STATE.IDLE;

    let selectedPassage;
    let startTime, endTime, focusTime = 0, tracking = false, videoStream = null, stopPressed = false;
    let pendingMetrics = null;
    let submitLocked = false;

    // Single source of truth for timer.
    let runStartEpochMs = 0;
    let elapsedMs = 0;
    let timerInterval = null;

    // Detection engine + loop control.
    let faceDetector = null;
    let blazeModel = null;
    let detectionEngine = 'none';
    let detectionActive = false;
    let detectionRaf = null;
    let lastDetectionTick = 0;

    // Tracking metrics.
    let facePresenceMs = 0;
    let lookingAwayMs = 0;
    let continuousAwayDurationMs = 0;
    let maxContinuousAwayMs = 0;
    let unstableSamples = 0;
    let detectionSamples = 0;
    let stableFaceSamples = 0;
    let lookAwayAlerts = 0;
    let eyeMovementScore = 0;

    function randomPick(items){ return items[Math.floor(Math.random()*items.length)]; }

    function loadPassage() {
      selectedPassage = randomPick(passages);
      document.getElementById('textToRead').innerText = selectedPassage.text;
      document.getElementById('questionBlock').style.display = 'none';
      document.getElementById('result').innerText = '';
    }

    function setCameraStatus(message, type='warning') {
      const cameraStatus = document.getElementById('cameraStatus');
      cameraStatus.style.display = 'block';
      cameraStatus.className = `alert alert-${type} py-2 mt-2`;
      cameraStatus.textContent = message;
    }

    function renderQuestion() {
      const block = document.getElementById('questionBlock');
      const optionsHost = document.getElementById('questionOptions');
      block.style.display = 'block';
      document.getElementById('questionText').textContent = selectedPassage.question;
      optionsHost.innerHTML = '';
      selectedPassage.options.forEach((opt, i) => {
        const id = `opt_${i}`;
        optionsHost.innerHTML += `<div class="form-check"><input class="form-check-input" type="radio" name="answer" id="${id}" value="${opt}"><label class="form-check-label" for="${id}">${opt}</label></div>`;
      });
      document.getElementById('submitAnswerBtn').style.display = 'inline-block';
      document.getElementById('submitAnswerBtn').disabled = false;
    }

    function stopFaceTracking() {
      if (faceTrackTimer) {
        clearInterval(faceTrackTimer);
        faceTrackTimer = null;
      }
      lastFaceCenter = null;
    }

    function updateTrackingPanel() {
      const panel = document.getElementById('trackingPanel');
      panel.style.display = 'block';

      const elapsedSeconds = Math.max(elapsedMs / 1000, 1);
      const qualityRatio = Math.min(facePresenceMs / (elapsedMs || 1), 1);
      const qualityPct = Math.round(qualityRatio * 100);

      panel.innerHTML = `Face presence: <strong>${Math.round(facePresenceMs / 1000)}s</strong> | Looking away: <strong>${Math.round(lookingAwayMs / 1000)}s</strong> | Eye movement: <strong>${eyeMovementScore.toFixed(1)}</strong> | Tracking quality: <strong>${qualityPct}%</strong> | Run time: <strong>${elapsedSeconds.toFixed(1)}s</strong>`;
    }

    function resetMetrics() {
      elapsedMs = 0;
      facePresenceMs = 0;
      lookingAwayMs = 0;
      continuousAwayDurationMs = 0;
      maxContinuousAwayMs = 0;
      unstableSamples = 0;
      detectionSamples = 0;
      stableFaceSamples = 0;
      lookAwayAlerts = 0;
      eyeMovementScore = 0;
      submitLocked = false;
      smoothedCenter = null;
      lastRawCenter = null;
      recentConfidences = [];
      pendingMetrics = null;
    }

    function startTimer() {
      stopTimer();
      runStartEpochMs = Date.now();
      timerInterval = setInterval(() => {
        if (testState !== STATE.RUNNING) return;
        elapsedMs = Date.now() - runStartEpochMs;
        updateTrackingPanel();
      }, 200);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

      stopFaceTracking();
      faceTrackTimer = setInterval(async () => {
        if (!tracking || !faceDetector || video.readyState < 2) return;
        try {
          const faces = await faceDetector.detect(video);
          if (!faces.length) {
            faceMissingStreak += 1;
            lookAwaySeconds += 1;
            if (faceMissingStreak === 2) {
              lookAwayAlerts += 1;
              setCameraStatus('Looking away detected. Please keep your face toward the screen.', 'danger');
            }
            updateTrackingPanel();
            return;
          }

    async function initDetectionEngine() {
      if (detectionEngine !== 'none') return true;
      if (detectorWarmupPromise) return detectorWarmupPromise;

      detectorWarmupPromise = (async () => {
        if ('FaceDetector' in window) {
          try {
            faceDetector = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
            detectionEngine = 'shape';
            return true;
          } catch (_error) {
            detectionEngine = 'none';
          }
        }
        try {
          await loadExternalScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js');
          await loadExternalScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js');
          blazeModel = await window.blazeface.load();
          detectionEngine = 'blazeface';
          return true;
        } catch (_error) {
          detectionEngine = 'none';
          return false;
        }
      })();
      return detectorWarmupPromise;
    }

    async function requestCameraStream() {
      const constraintsPrimary = { video: { facingMode: 'user', width: { ideal: 960 }, height: { ideal: 540 } }, audio: false };
      const constraintsFallback = { video: true, audio: false };
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        try { return await navigator.mediaDevices.getUserMedia(constraintsPrimary); }
        catch (_e) { return await navigator.mediaDevices.getUserMedia(constraintsFallback); }
      }
      return await new Promise((resolve, reject) => {
        const legacy = navigator.getUserMedia || navigator.webkitGetUserMedia;
        if (!legacy) return reject(new Error('No getUserMedia API'));
        legacy.call(navigator, constraintsFallback, resolve, reject);
      });
    }

    async function startWebcam() {
      const video = document.getElementById('webcam');
      faceVisibleSeconds = 0;
      eyeMovementScore = 0;
      lookAwaySeconds = 0;
      lookAwayAlerts = 0;
      faceMissingStreak = 0;
      document.getElementById('trackingPanel').style.display = 'none';
      stopFaceTracking();

      const mediaSupported = Boolean((navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || navigator.getUserMedia || navigator.webkitGetUserMedia);
      if (!mediaSupported) {
        tracking = true;
        trackFocusTime();
        setCameraStatus('Camera API is unavailable in this browser. Continuing test without camera/face tracking.', 'warning');
        updateTrackingPanel();
        return false;
      }

      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        setCameraStatus('Camera can be blocked on non-secure pages. Use localhost/https for reliable camera access.', 'warning');
      }
      lastDetectionTick = timestamp;

      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        cameraStatus.style.display = 'block';
        cameraStatus.className = 'alert alert-warning py-2 mt-2';
        cameraStatus.textContent = 'Camera may be blocked on non-secure pages. Use localhost/https for reliable camera access.';
      }

      const constraints = {
        video: {
          facingMode: 'user',
          width: { ideal: 960 },
          height: { ideal: 540 }
        },
        audio: false
      };

      try {
        videoStream = await requestCameraStream();
        video.srcObject = videoStream;
        video.style.display = 'block';
        try { await video.play(); } catch (_e) {}
        tracking = true;
        trackFocusTime();

        const faceTrackingEnabled = await setupFaceTracking(video);
        if (faceTrackingEnabled) {
          setCameraStatus('Camera active. Face/eye movement proxy tracking is enabled.', 'success');
        } else {
          setCameraStatus('Camera active. Face detector unsupported; using focus-time fallback.', 'warning');
        }
        updateTrackingPanel();
        return true;
      } catch (error) {
        tracking = true;
        trackFocusTime();
        setCameraStatus(`Camera access blocked/denied (${error.name || 'error'}). Test will continue without camera tracking.`, 'warning');
        updateTrackingPanel();
        return false;
      }

      detectionRaf = requestAnimationFrame(detectionTick);
    }

    function stopWebcam() {
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
      document.getElementById('webcam').style.display = 'none';
      tracking = false;
      stopFaceTracking();
    }

    async function ensureCameraReady() {
      if (videoStream) return true;

      const video = document.getElementById('webcam');
      const shell = document.getElementById('videoShell');
      const startCamBtn = document.getElementById('startCameraBtn');
      const stopCamBtn = document.getElementById('stopCameraBtn');

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        updateStatus('warning', 'Camera API is not supported in this browser.');
        return false;
      }

      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false,
        });
        video.srcObject = videoStream;
        shell.style.display = 'block';
        await video.play();

        document.getElementById('trackingHint').style.display = 'block';
        startCamBtn.style.display = 'none';
        stopCamBtn.style.display = 'inline-block';
        updateTrackingPanel();
        return true;
      } catch (_error) {
        updateStatus('warning', 'Camera permission denied or unavailable.');
        return false;
      }
    }

    function cleanupCamera() {
      stopDetection();
      if (videoStream) {
        videoStream.getTracks().forEach((track) => track.stop());
        videoStream = null;
      }
      const video = document.getElementById('webcam');
      video.srcObject = null;
      document.getElementById('videoShell').style.display = 'none';
      document.getElementById('trackingHint').style.display = 'none';
      document.getElementById('startCameraBtn').style.display = 'inline-block';
      document.getElementById('stopCameraBtn').style.display = 'none';

      const canvas = document.getElementById('faceOverlay');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Release detector references to avoid leaks between test sessions.
      faceDetector = null;
      blazeModel = null;
      detectionEngine = 'none';
    }

    document.getElementById('startCameraBtn').addEventListener('click', async function() {
      this.disabled = true;
      setCameraStatus('Starting camera...', 'info');
      await startWebcam();
      this.disabled = false;
    });

    document.getElementById('startBtn').addEventListener('click', async function() {
      focusTime = 0;
      startTime = Date.now();
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('stopBtn').style.display = 'block';
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('result').innerText = '';
      stopPressed = false;
      if (!videoStream) await startWebcam();
      else { tracking = true; trackFocusTime(); }
    });

    function stopRunningPhase() {
      if (testState !== STATE.RUNNING) return;
      stopTimer();
      stopDetection();
      elapsedMs = Date.now() - runStartEpochMs;
    }

    function buildTrackingQuality(metrics) {
      const total = Math.max(metrics.elapsedSeconds, 1);
      const presenceRatio = metrics.faceVisibleSeconds / total;
      const awayPenalty = Math.min(metrics.maxContinuousAwaySeconds / total, 1) * 0.25;
      const unstablePenalty = Math.min(metrics.unstableRate, 1) * 0.2;
      return Math.max(0, Math.min(1, presenceRatio - awayPenalty - unstablePenalty));
    }

    function finalizeSubmission() {
      const wordCount = document.getElementById('textToRead').innerText.trim().split(/\s+/).filter(Boolean).length;
      const elapsedSeconds = Math.max(elapsedMs / 1000, 1);
      const minExpectedSeconds = (wordCount / MAX_VALID_WPM) * 60;

      pendingMetrics = {
        elapsedSeconds,
        wordCount,
        minExpectedSeconds,
        focusTime: Math.round(elapsedMs / 1000),
        faceVisibleSeconds: Math.round(facePresenceMs / 1000),
        lookAwaySeconds: Math.round(lookingAwayMs / 1000),
        maxContinuousAwaySeconds: Math.round(maxContinuousAwayMs / 1000),
        eyeMovementScore,
        lookAwayAlerts,
        detectionSamples,
        stableFaceSamples,
        unstableRate: detectionSamples ? ((detectionSamples - stableFaceSamples) / detectionSamples) : 0,
      };
      pendingMetrics.trackingQuality = buildTrackingQuality(pendingMetrics);

      renderQuestion();
      document.getElementById('result').innerText = 'Submitted. Answer the comprehension question to complete validation.';
      setState(STATE.SUBMITTED);
    }

    document.getElementById('startCameraBtn').addEventListener('click', async () => {
      updateStatus('info', 'Preparing camera and face detector...');
      await initDetectionEngine();
      const ok = await ensureCameraReady();
      if (ok && testState === STATE.RUNNING) {
        await startDetection();
      }
    });

    document.getElementById('stopCameraBtn').addEventListener('click', () => {
      cleanupCamera();
      updateStatus('warning', 'Camera stopped. Tracking paused until camera restarts.');
    });

    document.getElementById('startBtn').addEventListener('click', async () => {
      submitLocked = false;
      await startTestFlow();
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
      if (testState !== STATE.RUNNING || submitLocked) return;
      submitLocked = true;
      stopRunningPhase();
      finalizeSubmission();
    });

    document.getElementById('submitAnswerBtn').addEventListener('click', () => {
      if (testState !== STATE.SUBMITTED || !pendingMetrics) return;
      const chosen = document.querySelector('input[name="answer"]:checked');
      if (!chosen) {
        document.getElementById('result').innerText = 'Please select an answer before finishing submission.';
        return;
      }
      const correct = chosen.value === selectedPassage.answer;
      const rawWpm = (pendingMetrics.wordCount / pendingMetrics.elapsedSeconds) * 60;
      const wordsPerMinute = Math.min(rawWpm, MAX_VALID_WPM);

      // Reliability only indicates data quality, never user performance.
      const dataComplete = pendingMetrics.elapsedSeconds >= 1 && pendingMetrics.wordCount >= 10;
      const cameraUsable = pendingMetrics.detectionSamples === 0
        ? false
        : ((pendingMetrics.faceVisibleSeconds / Math.max(pendingMetrics.elapsedSeconds, 1)) >= 0.35);
      const qualityTag = dataComplete && (cameraUsable || pendingMetrics.focusTime >= MIN_VALID_FOCUS_SECONDS)
        ? 'usable'
        : 'needs_review';

      const comprehensionAccuracy = correct ? 100 : 0;
      document.getElementById('result').innerText = `Reading score recorded: ${wordsPerMinute.toFixed(2)} WPM | Comprehension: ${comprehensionAccuracy}% | Face Presence: ${pendingMetrics.faceVisibleSeconds}s | Looking Away: ${pendingMetrics.lookAwaySeconds}s | Tracking Quality: ${(pendingMetrics.trackingQuality * 100).toFixed(0)}%`;
      sessionStorage.setItem('reading_speed_score', wordsPerMinute.toFixed(2));
      sessionStorage.setItem('reading_speed_reliability', qualityTag);
      sessionStorage.setItem('reading_comprehension_accuracy', String(comprehensionAccuracy));
      sessionStorage.setItem('camera_reliability', (pendingMetrics.trackingQuality * 100).toFixed(0));
      sessionStorage.setItem('attention_stability', (Math.max(0, 100 - pendingMetrics.lookAwaySeconds * 8)).toFixed(2));
      sessionStorage.setItem('movement_variability', pendingMetrics.eyeMovementScore.toFixed(2));

      sessionStorage.setItem('focus_time', String(pendingMetrics.focusTime));
      sessionStorage.setItem('face_presence_time', String(pendingMetrics.faceVisibleSeconds));
      sessionStorage.setItem('eye_movement_index', pendingMetrics.eyeMovementScore.toFixed(2));
      sessionStorage.setItem('looking_away_seconds', String(pendingMetrics.lookAwaySeconds));
      sessionStorage.setItem('tracking_quality', (pendingMetrics.trackingQuality * 100).toFixed(0));

      document.getElementById('submitAnswerBtn').disabled = true;
      updateStatus('success', 'Submission completed. You can finish or restart the test.');
      setState(STATE.FINISHED);
    });

    document.getElementById('finishTestBtn').addEventListener('click', function() {
      window.location.href = '/dyslexia-prediction';
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadPassage();
      setState(STATE.IDLE);
      updateTrackingPanel();
      // Warm detector before test starts to avoid 5-10s startup delay.
      setTimeout(() => { initDetectionEngine().catch(() => {}); }, 250);
    });
  </script>
</body>
</html>
